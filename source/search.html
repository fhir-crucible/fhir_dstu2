<!DOCTYPE HTML>

[%settitle Search (RESTful API) %]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]

<div class="col-9">

<a name="base"> </a>
<h2>Search</h2>
<table class="cols"><tr><td id="wg"><a _target="blank" href="[%wg fhir%]">[%wgt fhir%]</a> Work Group</td><td id="fmm"><a href="resource.html#maturity">Maturity Level</a>: N/A</td><td id="ballot"><a href="help.html#status">Ballot Status</a>: <a href="history.html#pubs">DSTU 2</a></td></tr></table>

<p>
One aspect that is fundamental to the way FHIR works is to search a set of resources.
Search operations search through an existing set of resources by a set
of search criteria supplied as parameters to the search. This page documents
the FHIR search framework, starting with the simple cases, and working through
to the full complexity. Implementations need only implement the amount of
complexity that they require.
</p>

<h3>Summary Table</h3>

<table class="grid">
<tr><td><b>Search Parameter Types</b></td><td><b>Parameters for all resources</b></td><td><b>Search result parameters</b></td></tr>
<tr>
<td>
<%codetoc http://hl7.org/fhir/ValueSet/search-param-type%>
</td>
<td>
<a href="#id">_id</a><br/>
<a href="#lastUpdated">_lastUpdated</a><br/>
<a href="#tag">_tag</a><br/>
<a href="#profile">_profile</a><br/>
<a href="#security">_security</a><br/>
<a href="#text">_text</a><br/>
<a href="#content">_content</a><br/>
<a href="#list">_list</a><br/>
<a href="#query">_query</a><br/>
</td>
<td>
<a href="#sort">_sort</a><br/>
<a href="#count">_count</a><br/>
<a href="#include">_include</a><br/>
<a href="#revinclude">_revinclude</a><br/>
<a href="#summary">_summary</a><br/>
<a href="#elements">_elements</a><br/>
<a href="#contained">_contained</a><br/>
<a href="#containedType">_containedType</a><br/>
</td>
</tr>
</table>
<p>
In addition, there is a special search parameter <a href="#filter">_filter</a> that allows a different method of searching.
</p>

<h3>Introduction</h3>
<p>
In the simplest case, a search is executed by performing a GET operation
in the RESTful framework:
</p>
<pre>
 GET [base]/[resourcetype]?name=value&amp;...
</pre>
<p>
For this RESTful search (see <a href="http.html#search">definition in RESTful API</a>), the parameters are a series
of name=[value] pairs encoded in the URL or as an
application/x-www-form-urlencoded submission for a POST:
</p>
<pre>
 POST  [base]/[type]/_search{?[parameters]{&amp;_format=[mime-type]}}
</pre>
<p>
The server returns the results in the HTTP response as a <a href="bundle.html">bundle</a>
which includes the resources that are the results of the search. 
</p>
<p>
<a href="http.html#search">Search operations</a> are executed in one of 3 defined contexts that control which set of resources are being searched:
</p>
<ul>
 <li>A specified resource type: GET [base]/[ResourceType]?parameter(s)</li>
 <li>A specified <a href="compartments.html#compartments">compartment</a>, perhaps with a specified resource type in that compartment: GET [base]/Patient/[id]/[ResourceType]?parameter(s)</li>
 <li>All resource types: GET [base]/_search?parameter(s) (parameters common to all types only)</li>
</ul>
<p>
Search operations can also be implemented in <a href="messaging.html#search">the messaging framework</a>.
</p>

<a name="errors"> </a>
<h3>Handling Errors</h3>
<p>
If a server is unable to execute a search request, it may return an error. 
A HTTP status code of 403 signifies that the server refused to perform the search,
while some other 4xx or 5xx code signifies that some error occurred. When
the search fails, a server SHOULD return an <a href="operationoutcome.html">OperationOutcome</a>
detailing the cause of the failure. Note that an empty search result is not a failure.
</p>
<p>
In some cases, some of the parameters may have problems. For instance:
</p>
<ul>
 <li>A parameter may refer to a non-existent resource e.g. GET [base]/Observation?subject=101, where 101 does not exist</li>
 <li>A parameter may refer to an unknown code e.g. GET [base]/Observation?code=loinc|1234-1, where the LOINC code 1234-1 is not known to the server</li>
 <li>A parameter may refer to a time that is out of scope e.g. GET [base]/Condition?onset=le1995, where the system only has data going back to 2001</li>
 <li>A parameter may use an illegal or unaaceptable modifier e.g. GET [base]/Condition?onset:text=1995, where the modifier cannot be processed by the server</li>
 <li>A data time parameter may have incorrect format e.g. GET [base]/Condition?onset=23%20May%202009</li>
</ul>
<p>
Where the content of the parameter is syntactically correct, servers SHOULD return an error. 
However where the issue is a logical condition (e.g. unknown subject or code), the server 
SHOULD process the search, including processing the parameter - with the effect of returning
an empty search set, since the parameter cannot be satisfied. 
</p>
<p>
In such cases, the search process MAY include an <a href="operationoutcome.html">OperationOutcome</a>
in the search set that contains additional hints and warnings about the search process.
This is included in the search results as an entry with <a href="bundle-definitions.html#Bundle.entry.search.mode">search mode</a> = <a href="valueset-search-entry-mode.html">outcome</a>.
Clients can use this information to improve future searches.
</p>

<a name="standard"> </a>
<h3>Standard Parameters</h3>

<a name="all"> </a>
<h4>Parameters for all resources</h4>
<p>
These parameters are <a href="resource.html#search">defined that apply to all resources</a>: [%allparams%]. In addition, the search 
parameter <a href="#text">_text</a> and <a href="#filter">_filter</a>, (documented below) also applies to all resources (as do the search result parameters). 
</p>
<a name="id"> </a>
<p> 
The search parameter _id refers to the logical id of the resource, and can be used when the search context specifies a resource type:
</p>
<pre>
 GET [base]/Patient?_id=23
</pre>
<p>
This search finds the patient resource with the given id (there can only be one
resource for a given id). Functionally, this is equivalent to a <a href="http.html#read">simple
read operation</a>:
</p>
<pre>
 GET [base]/Patient/23
</pre>
<p>
except that it returns a bundle with the requested resource, rather than the
resource itself. Additional parameters can be added which may provide
additional functionality on top of this base read equivalence.
</p>
<a name="lastUpdated"> </a>
<p>
The search parameter _lastUpdated can be used to select resources based
on the last time they were changed:
</p>
<pre>
 GET [base]/Observation?_lastUpdated=>2010-10-01
</pre>
<p>
This search finds any observations changed since 1-Oct 2010. When
this search parameter is used, applications should consider
synchronization approaches (<a href="http.html#history">RESTful history</a>
or the <a href="subscription.html">Subscription resource</a>).
</p>
<a name="tag"> </a>
<a name="tags"> </a>
<a name="profile"> </a>
<a name="security"> </a>

<p>
The search parameters _tag, _profile and _security parameters search
on the equivalent elements in the <a href="resource.html#meta">meta element</a>.
For example
</p>
<pre>
 GET [base]/Condition?_tag=http://acme.org/codes|needs-review
</pre>
<p>
searches for all Condition resources with the tag:
</p>
<pre class="json">
{
  "system" : "http://acme.org/codes",
  "code" : "needs-review"
}
</pre>
<p>
In the same manner:
</p>
<pre>
 GET [base]/DiagnosticReport?_profile=http://hl7.org/fhir/StructureDefinition/lipid
 GET [base]/DiagnosticReport?_profile=Profile/lipid
</pre>
<p>
restricts the search to only DiagnosticReport resources that are tagged that they conform to a particular profile.
The second reference is relative, and refers a local profile on the same server.
</p>
<p>
_tag, _profile and _security parameters are all token types (see <a href="#token">below</a>).
</p>


<h4>Parameters for each resource</h4>
<p>
In addition to the _id parameter which exists for all resources, each
FHIR resource type defines its own set of search parameters with
their names, types, and meanings. These search parameters are on the
same page as the resource definitions, and are also published as part
of the standard conformance statement (<a href="conformance-base.xml.html">XML</a> or <a href="conformance-base.json.html">JSON</a>).
</p>
<p>
Mostly, the defined search parameters correspond to a
single element in the resource, but this is not required, and some
search parameters refer to the same type of element in multiple
places, or refer to derived values.
</p>
<p>
Some of the search parameters defined by the resources are associated
with more than one path in the resource. This means that the search
parameter matches if any of the paths contain matching content, and
which ever path matches, the whole resource is returned in the
search results. The client may have to examine the resource to determine
which path contains the match.
</p>
<p>
Servers are not required to implement any of these search parameters
(except for the _id parameter described above), and may define their own
additional parameters if they wish.
</p>

<a name="ptypes" />
<h4>Search Parameter Types</h4>
<p>Each search parameter is defined with a type that defines how the search parameter
behaves. These are the defined parameter types:
</p>
<%linkcodelist http://hl7.org/fhir/ValueSet/search-param-type%>
<p>
The search parameters can also have "modifiers" appended to them that control
their behavior. The kinds of modifiers that can be used depend on the type
of parameter.
</p>

<a name="modifiers" />
<h4>Modifiers</h4>
<p>Parameters are defined per resource, and their names may additionally specify a modifier as a suffix,
separated from the parameter name by a colon. Modifiers are:</p>
<ul>
 <li>For all parameters (except combination): <code>:missing</code>. E.g. gender:missing=true (or false).
  Searching for "gender:missing=true" will return all the resources that don't have any value for the gender parameter (which usually
  equates to not having the relevant element in the resource). Searching for "gender:missing=false"
  will return all the resources that have a value for the "gender" parameter. </li>
 <li>For string: <code>:exact</code> (the match needs to be exact, no partial matches, case sensitive and accent-sensitive), or <code>:contains</code> (case insensitive and accent-insensitive, partial match at start or end), instead of the default behavior (case insensitive and accent-insensitive, partial matches at the end of the string)</li>
 <li>For token: <code>:text</code> (the match does a partial searches on the text portion of a CodeableConcept or the display portion of a Coding), instead of the default search which uses codes. Other define modifiers are <code>:in</code>, <code>:below</code>, <code>:above</code> and <code>:not-in</code> which are described below</li>
 <li>For reference: <code>:[type]</code> where [type] is the name of a type of resource</li>
 <li>For uri: <code>:below</code>, <code>:above</code> indicate that instead of an exact match, either the search term left matches the value, or vice-versa</li>
</ul>
<p>
Server SHALL reject any search request that contains is suffixed by a modifier that the 
server does <b>not</b> support for that parameter. For example, if the server supports 
the "name" search param, but not the ":exact" modifier on the name, it should reject a 
search with the parameter "name:exact=Bill", using an HTTP 400 error with
an <a href="operationoutcome.html">OperationOutcome</a> with a <a href="operationoutcome-example-searchfail.html">clear error message</a>.

</p>

<a name="prefix" />
<h4>Prefixes</h4>
<p>
For the ordered parameter types <a href="#number">number</a>, <a href="#date">date</a>, and <a href="#quantity">quantity</a>, 
a prefix to the parameter value may be used to control the nature of the matching. To avoid URL escaping and visual confusion,
the following prefixes are used:
</p>
<table class="grid">
 <tr>
	<td>eq</td>
	<td>the value for the parameter in the resource is equal to the provided value</td>
	<td>the range of the search value fully contains the range of the target value</td>
 </tr>
 <tr>
	<td>ne</td>
	<td>the value for the parameter in the resource is not equal to the provided value</td>
  <td>the range of the search value does not fully contain the range of the target value</td>
 </tr>
 <tr>
	<td>gt</td>
	<td>the value for the parameter in the resource is greater than the provided value</td>
  <td>the range above the search value intersects (i.e. overlaps) with the range of the target value</td>
 </tr>
 <tr>
	<td>lt</td>
	<td>the value for the parameter in the resource is less than the provided value</td>
  <td>the range below the search value intersects (i.e. overlaps) with the range of the target value</td>
 </tr>
 <tr>
	<td>ge</td>
	<td>the value for the parameter in the resource is greater or equal to the provided value</td>
  <td>the range above the search value intersects (i.e. overlaps) with the range of the target value, or the range of the search value fully contains the range of the target value</td>
 </tr>
 <tr>
	<td>le</td>
	<td>the value for the parameter in the resource is less or equal to the provided value</td>
  <td>the range below the search value intersects (i.e. overlaps) with the range of the target value or the range of the search value fully contains the range of the target value</td>
 </tr>
 <tr>
	<td>sa</td>
	<td>the value for the parameter in the resource starts after the provided value</td>
  <td>the range of the search value does overlap with the range of the target value, and the range below the search value contains the range of the target value</td>
 </tr>
 <tr>
	<td>eb</td>
	<td>the value for the parameter in the resource ends before the provided value</td>
  <td>the range of the search value does overlap with the range of the target value, and the range above the search value contains the range of the target value</td>
 </tr>
 <tr>
	<td>ap</td>
	<td>the value for the parameter in the resource is approximately the same to the provided value.<br/> 
	Note that the recommended value for the approximation is 10% of the stated value (or for a date, 10% of the gap between now and the date), but systems may choose other values where appropriate</td>
  <td>the range of the search value overlaps with the range of the target value</td>
 </tr>
</table>
<p>
If no prefix is present, the prefix 'eq' is assumed. Note that the way search parameters operate 
is not the same as the way the operations on two numbers work in a mathematical sense. <code>sa</code> ('starts-after') and 
<code>eb</code> ('ends-before') are not used with integer values.
</p>
<p>
For each prefix above, two interpretations are provided - the simple intent of the prefix, and the 
interpretation of the parameter when applied to ranges. The range interpretation is provided
because for decimals and dates, the searches are always performed on values that are implicitly
or explicitly a range. For instance, the number 2.0 has an implicit range of 
1.95 to 2.05, and the date 2015-08-12 has an implicit range of the all the time during that day. 
If the target value is a <a href="datatypes.html#range">Range</a>, a <a href="datatypes.html#period">Period</a>, 
or a <a href="datatypes.html#timing">Timing</a>, then the target is explicitly a range. Three ranges 
are identified:
</p>
<table class="grid">
 <tr>
	<td>range of the value</td>
	<td>The limits implied by the precision of the value</td>
  <td>The number 2.0 has a range of 1.95 to 2.05<br/>
      The date 2015-08-12 has a range from 00:00 to 00:00 exclusive</td>
 </tr>
 <tr>
	<td>range below the value</td>
	<td>Up to the specified value</td>
  <td>The range below 2.0 includes any value less or equal to &lt;2.00000000000000000000<br/>
      The range before 2015-08-12T05:23:45 includes any time up to 2015-08-12T05:23:45.000000000000000</td>
 </tr>
 <tr>
	<td>range above the value</td>
	<td>The specified value and up</td>
  <td>The range above 2.0 includes any value greater or equal to &lt;2.00000000000000000000<br/>
      The range after 2015-08-12T05:23:45 includes any time up to 2015-08-12T05:23:45.000000000000000</td>
 </tr>
</table>
<p>
The proper use of these is discussed further below. 
</p>

<a name="number" />
<h4>number</h4>
<p>
Sarching on a simple numerical value in a resource. Examples:
</p>
<table class="grid">
 <tr><td>[parameter]=100</td><td>Values that equal 100, to 2 significant figures precision, so range [99.5 ... 100.5)</td></tr>
 <tr><td>[parameter]=100.00</td><td>Values that equal 100, to 4 significant figures precision, so range [99.995 ... 100.005). Whole numbers also equal 100.00, but not 100.01</td></tr>
 <tr><td>[parameter]=lt100</td><td>Values that are less than 100</td></tr>
 <tr><td>[parameter]=le100</td><td>Values that are less or equal to 100</td></tr>
 <tr><td>[parameter]=gt100</td><td>Values that are greater than 100</td></tr>
 <tr><td>[parameter]=ge100</td><td>Values that are greater or equal to 100</td></tr>
 <tr><td>[parameter]=ne100</td><td>Values that are not equal to 100</td></tr>
</table>
<p>
Note that uncertainty does not factor in evaluations, and the precision of the numbers is considered arbitrarily high (the 
way these search parameters operate here is not the same as whether two numbers are equal to each other in a mathematical sense).
</p>

<a name="date" />
<h4>date</h4>
<p>
A date parameter searches on a date/time or period. As is usual for date/time related functionality, while the
concepts are relatively straight-forward, there are a number of subtleties involved in ensuring consistent behavior.
</p>
<p>
The date parameter format is yyyy-mm-ddThh:nn:ss(TZ) (the standard XML format).
</p>
<p>
Technically, this is any of the <a href="datatypes.html#date">date</a>, <a href="datatypes.html#dateTime">dateTime</a>, 
and <a href="datatypes.html#instant">instant</a> data types.  e.g. Any degree of precision can be provided, but it SHALL 
be populated from the left (e.g. can't specify a month without a year), except that the minutes SHALL be present if 
an hour is present, and you SHOULD provide a time zone if the time part is present. Note that the time can be 
just hours and minutes with no seconds, unlike the XML Schema dateTime type. Some user agents may escape the ":" 
characters in the URL, and servers SHALL handle this correctly.
</p>
<p>
Date parameters may be used with the following data types:
</p>
<table class="grid">
 <tr><td><a href="datatypes.html#date">date</a></td><td>The range of the value is the day, month, or year as specified</td></tr>
 <tr><td><a href="datatypes.html#dateTime">dateTime</a></td><td>The range of the value as defined above. e.g. For example, the 
   date 2013-01-10 specifies all the time from 00:00 on 10-Jan 2013 to immediately before 00:00 on 11-Jan 2013</td></tr>
 <tr><td><a href="datatypes.html#instant">instant</a></td><td>An instant is considered a fixed point in time with an interval smaller than the precision of the system, i.e. an interval with an effective width of 0</td></tr>
 <tr><td><a href="datatypes.html#Period">Period</a></td><td>Explicit, though the upper or lower bound may not actually be specified in resources</td></tr>
 <tr><td><a href="datatypes.html#Timing">Timing</a></td><td>the specified scheduling details are ignored and only the outer limits matter. For instance, a schedule that specifies every second day between
   31-Jan 2013 and 24-Mar 2013 includes 1-Feb 2013, even though that is on an odd day that is not specified by the period. This is
   to keep the server load processing queries reasonable</td></tr>
</table>
<p>
Implicitly, a missing lower boundary is 'less than' any actual date.  A missing upper boundary is 'greater than' any actual date.
The use of the prefixes:
</p>
<table class="grid">
 <tr><td>[parameter]=eq2013-01-14</td><td>matches 2013-01-14T00:00 (obviously) and also 2013-01-14T10:00 but not 2013-01-15T00:00</td></tr>
 <tr><td>[parameter]=ne2013-01-14</td><td>matches 2013-01-15T00:00 but not 2013-01-14T00:00 or 2013-01-14T10:00</td></tr>
 <tr><td>[parameter]=lt2013-01-14T10:00</td><td>Includes the time 2013-01-14, because it includes the part of 14-Jan 2013 before 10am </td></tr>
 <tr><td>[parameter]=gt2013-01-14T10:00</td><td>Includes the time 2013-01-14, because it includes the part of 14-Jan 2013 after 10am</td></tr>
 <tr><td>[parameter]=ge2013-03-14</td><td>Incldues the period from 21-Jan 2013 onwards, because it may include times after 14-Mar 2013</td></tr>
</table>
<p>
Other notes:
</p>
<ul>
 <li>When the date parameter is not fully specified, matches against it are based on the behavior of intervals, where:
	<ul>
		<li>Dates with just the year specified are equivalent to an interval that starts at the first instant of January 1st to the last instant of December 31st, e.g. 2000 is equivalent to an interval of [2000-01-01T00:00, 2000-12-31T23:59]</li>
		<li>Dates with the year and month are equivalent to an interval that starts at the first instant of the first day of the month and ends on the last instant of the last day of the month, e.g. 2000-04 is equivalent to an interval of [2000-04-01T00:00, 2000-04-30T23:59]</li>
	</ul>
 </li>
 <li>Where possible, the system should correct for timezones when performing queries. Dates do not have time zones, and time zones
   should not be considered. Where both search parameters and resource element date times do not have time zones, the servers local
   time zone should be assumed.
 </li>
</ul>
<p>
To search for all the procedures in a patient compartment that occurred over a 2 year period:
</p>
<pre>
 GET [base]/Patient/23/Procedure?date=ge2010-01-01&amp;date=le2011-12-31
</pre>


<a name="string" />
<h4>string</h4>
<p>
The string parameter refers to simple string searches against sequences of characters. 
Matches are case- and accent- insensitive. By default, a field matches a string query 
if the value of the field equals or starts with the supplied parameter value, after 
both have been normalized by case and accent. The <code>:contains</code> modifier 
returns results that include the supplied parameter value anywhere within the field 
being searched. The <code>:exact</code> modifier returns results that exactly match 
the supplied parameter (the whole string, including casing and accents).
</p>
<p>
Examples:
</p>
<table class="grid">
 <tr><td>[base]/Patient?name=eve</td><td>any patients with a name starting with "eve" at the start of the name. This would include patients with the name "Eve", "Evelyn"</td></tr>
 <tr><td>[base]/Patient?name:contains=eve</td><td>any patients with a name starting with "eve" at the start of the name. This would include patients with the name "Eve", "Evelyn", and also "Severine"</td></tr>
 <tr><td>[base]/Patient?name:exact=Eve</td><td>any patients with a name starting with "eve" at the start of the name. This would include patients with the name "Eve" but not "eve" or "EVE"</td></tr>
</table>
<p>
An additional modifier <code>:text</code>
can be used to specify a search with advanced text handling (see <a href="#text">below</a>)
though only a few servers are expected to offer this facility.
</p>
<p>
It is at the discretion of the server whether to pre-process names, addresses,
and contact details to remove separator characters prior to matching in order
to ensure more consistent behavior. For example, a server might remove all
spaces and "-" characters from phone numbers. What is most appropriate varies
depending on culture and context.
</p>


<a name="uri" />
<h4>uri</h4>
<p>
The uri parameter refers to an element which is URI (<a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a>).
Matches are precise (e.g. case, accent, and escape) sensitive, and the entire URI must match. 
The modifier <code>:above</code> or <code>:below</code> can be used to indicate
that partial matching is used. For example:
</p>
<pre>
 GET [base]/ValueSet?url=http://acme.org/fhir/ValueSet/123
 GET [base]/ValueSet?url:below=http://acme.org/fhir/
</pre>
<p>
The first is a request to find any value set with the exact url "http://acme.org/fhir/ValueSet/123". 
The second search will return any value sets that have a URL that starts with "http://acme.org/fhir/".
The converse - the search for any value set above a given specific URL - may be useful for searching
name systems, but it is generally less useful than the <code>:below</code> search. 
</p>

<a name="token" />
<h4>token</h4>
<p>
A token type is a parameter that searches on a pair, a URI and a value. It is used against
 code or identifier value where the value may 
have a URI that scopes its meaning. The search is performed against the  pair from a Coding or an Identifier. The syntax for the value is one of the following:
</p>
<ul>
 <li><b>[parameter]=[code]</b>: the value of [code] matches a Coding.code or Identifier.value irrespective of the value of the system property</li>
 <li><b>[parameter]=[system]|[code]</b>: the value of [code] matches a Coding.code or Identifier.value, and the value of [system] matches the system property of the Identifier or Coding</li>
 <li><b>[parameter]=|[code]</b>: the value of [code] matches a Coding.code or Identifier.value, and the Coding/Identifier has no system property</li>
</ul>
<p>
Note that the namespace URI and code both must be <a href="#escaping">escaped</a>. Matches are literal (e.g. not based on subsumption or other code system features), but not case sensitive.
</p>
<p>
Token search parameters are used for the following data types:
</p>
<table class="lines">
 <tr>
  <td><b>Data Type</b></td>
  <td><b>URI</b></td>
  <td><b>Code</b></td>
  <td><b>Comments</b></td>
 </tr>
 <tr>
  <td><a href="datatypes.html#Coding">Coding</a></td>
  <td>Coding.system</td>
  <td>Coding.code</td>
  <td></td>
 </tr>
 <tr>
  <td><a href="datatypes.html#CodeableConcept">CodeableConcept</a></td>
  <td>CodeableConcept.coding.system</td>
  <td>CodeableConcept.coding.code</td>
  <td>Matches against any coding in the CodeableConcept</td>
 </tr>
 <tr>
  <td><a href="datatypes.html#Identifier">Identifier</a></td>
  <td>Identifier.system</td>
  <td>Identifier.value</td>
  <td></td>
 </tr>
 <tr>
  <td><a href="datatypes.html#Identifier">ContactPoint</a></td>
  <td>ContactPoint.use</td>
  <td>ContactPoint.value</td>
  <td>The use is prepended by <a href="valueset-contact-point-system.html">http://hl7.org/fhir/contact-point-system</a>/</td>
 </tr>
 <tr>
  <td><a href="datatypes.html#code">code</a></td>
  <td>(implicit)</td>
  <td>code</td>
  <td>the system is defined in the value set (though it's not usually needed)</td>
 </tr>
 <tr>
  <td><a href="datatypes.html#boolean">boolean</a></td>
  <td>(implicit)</td>
  <td>boolean</td>
  <td>The implicit system is <a href="valueset-special-values.html">http://hl7.org/fhir/special-values</a></td>
 </tr>
 <tr>
  <td><a href="datatypes.html#string">string</a></td>
  <td>n/a</td>
  <td>string</td>
  <td>Token is sometimes used for string to indicate that exact matching is the correct default search stategy</td>
 </tr>
</table>
<p>
Note about the use of token search parameters for boolean fields: the boolean values 'true' and 'false' are also represented
as formal codes in the <a href="valueset-special-values.html">Special Values</a> code system, which is useful when boolean values 
need to be represented in a <a href="datatypes.html#coding">Coding</a> data type. The namespace for these codes is 
http://hl7.org/fhir/special-values, though there is usually no reason to use this, as a simple true or false is sufficient.
</p>

<p><b>Modifiers:</b></p>
<table class="lines">
 <tr> <td><b>Modifier</b></td> <td><b>Use</b></td> </tr>
 <tr> <td><code>:text</code></td> <td>the search parameter is processed as a string that searches text associated with the code/value - either <i>CodeableConcept.text</i>, <i>Coding.display</i>, or <i>Identifier.type.text</i></td> </tr>
 <tr> <td><code>:not</code></td> <td>reverse the code matching described in the paragraph above</td> </tr>
 <tr> <td><code>:above</code></td> <td>the search parameter is a concept with the form [system]|[code], and the search parameter tests whether the coding in a resource subsumes the specified search code (e.g. the search concept has an is-a relationship with the coding in the resource, and this includes the coding itself)</td> </tr>
 <tr> <td><code>:below</code></td> <td>the search parameter is a concept with the form [system]|[code], and the search parameter tests whether the coding in a resource is subsumed by the specified search code (e.g. the coding in the resource has an is-a relationship with the search concept, and this includes the coding itself)</td> </tr>
 <tr> <td><code>:in</code></td> <td>the search parameter is a URI (relative or absolute) that identifies a value set, and the search parameter tests whether the coding is in the specified <a href="valueset.html">value set</a>. The reference may be literal (to an address where the value set can be found) or logical (a reference to ValueSet.url)</td> </tr>
 <tr> <td><code>:not-in</code></td> <td>the search parameter is a URI (relative or absolute) that identifies a value set, and the search parameter tests whether the coding is not in the specified value set</td> </tr>
</table>
<p>
Most servers will only process value sets that are already known/registered/supported internally, but servers can elect to accept any valid reference to a value set.
Servers may elect to consider concept mappings when testing for subsumption relationships.
</p>

<p>
Here are some example searches:
</p>
<table>
 <tr><td width="50%"><b>Search</b></td><td><b>Description</b></td></tr>
 <tr><td><pre> GET [base]/Patient?identifier=http://acme.org/patient|2345</pre></td><td>Search for all the patients with an identifier with key = "2345" in the system "http://acme.org/patient"</td></tr>
 <tr><td><pre> GET [base]/Patient?gender=male</pre></td><td>Search for any patient with a gender that has a code "male", irrespective of the system. Note that this usually isn't very useful - systems generally define symbols where overlap is coincidental and not informative</td></tr>
 <tr><td><pre> GET [base]/Patient?gender=http://hl7.org/fhir/v2/0001|M</pre></td><td>Search for any patient with a gender which is coded as "M" in the HL7 Administrative Gender table</td></tr>
 <tr><td><pre> GET [base]/Patient?gender:text=male</pre></td><td>Search for any patient with a gender that has a text "male" associated with it (note: this will include "female")</td></tr>
 <tr><td><pre> GET [base]/Patient?active=true</pre></td><td>Search for any patients that are active</td></tr>
</table>


<a name="quantity" />
<h4>quantity</h4>
<p>
A quantity parameter searches on the <a href="datatypes.html#Quantity">Quantity</a> data type.
The syntax for the value follows the form:
</p>
<ul>
 <li><b>[parameter]=[prefix][number]|[system]|[code]</b> matches a quantity with the given unit</li>
</ul>
<p>
The prefix optional, and is as described <a href="#prefix">above</a>. Example searches:
</p>

<table>
 <tr><td width="50%"><b>Search</b></td><td><b>Description</b></td></tr>
 <tr><td><pre> GET [base]/Observation?value=5.4|http://unitsofmeasure.org|mg</pre></td><td>Search for all the observations with a value of 5.4 mg where mg is understood as a UCUM unit (system/code)</td></tr>
 <tr><td><pre> GET [base]/Observation?value=5.4||mg</pre></td><td>Search for all the observations with a value of 5.4 mg where the units - either the code  or the stated human units (units) are "mg"</td></tr>
 <tr><td><pre> GET [base]/Observation?value=le5.4|http://unitsofmeasure.org|mg</pre></td><td>Search for all the observations where the value of is less than 5.4 mg where mg is understood as a UCUM unit</td></tr>
 <tr><td><pre> GET [base]/Observation?value=ap5.4|http://unitsofmeasure.org|mg</pre></td><td>Search for all the observations where the value of is about 5.4 mg where mg is understood as a UCUM unit</td></tr>
</table>

<p>
The search processor may choose to perform a search based on <a href="datatypes.html#quantity">canonical units</a> (e.g. any value where the units can be converted to a value in mg in the case above)
</p>


<a name="chaining" />
<a name="reference" />
<h4>reference</h4>
<p>
A reference parameter refers to <a href="references.html">references between resources</a>, e.g. find all
Conditions where the subject reference is a particular patient, where the patient is selected by name or identifier.
The interpretation of a <i>reference</i> parameter is either:
</p>
<ul>
 <li><b>[parameter]=[id]</b> the logical [id] of a resource using a local reference (i.e. a relative reference)</li>
 <li><b>[parameter]=[type]/[id]</b> the logical [id] of a resource of a specified type using a local reference (i.e. a relative reference), 
   for when the reference can point to different types of resources (e.g. <a href="observation-definitions.html#Observation.subject">Observation.subject</a>)</li>
 <li><b>[parameter]=[url]</b> where the [url] is an absolute URL - a reference to a resource by its absolute location</li>
</ul>
<p>
Note that if a relative reference resolves to the same value as a specified absolute URL, or vice versa, this is a match too.
</p>
<p>
Some references are allowed to point to more than one type of resource. e.g. subject : Reference(Patient|Group|Device|..).
In these cases, multiple different resources may have the same logical identifier. Servers SHOULD reject a search where 
the logical id refers to more than one matching resource across different types.
In order to allow the client to perform a search in these situations can specify the type explicitly:
</p>
<pre>
 GET [base]/Condition?subject=Patient/23
</pre>
<p>
This searches for any conditions where the subject refers to the patient resource with the
logical identifier "23". A modifier is also defined to to allow the client to be explicit 
about the intended type:
</p>
<pre>
 GET [base]/Condition?subject:Patient=23
</pre>
<p>
This has the same effect as the previous search. The modifier becomes useful when used with chaining
as in explained in the next section. Note that the <code>[type]</code> modifier can't be used with a reference to a resource found on another server, 
since the server would not usually know what type that resource has (but since these are absolute references, 
there can be no ambiguity about the type).
</p>

<h4>Chained parameters</h4>
<p>
In order to save a client from doing a series of search operations,
reference parameters may be "chained" by appending them with
a period (.) followed by the name of a search parameter defined for the target
resource. This can be done recursively, following a logical path
through a graph of related resources, separated by ".".
For instance, given that
the resource <a href="diagnosticreport.html">DiagnosticReport</a>
has a search parameter named <i>subject</i>, which is usually a
reference to a <a href="patient.html">Patient</a> resource, and
the Patient resource includes a parameter <i>name</i> which
searches on patient name, then the search
</p>
<pre>
 GET [base]/DiagnosticReport?subject.name=peter
</pre>
<p>
is a request to return all the lab reports that have a subject whose name includes "peter". Because
the Diagnostic Report subject can be one of a set of different resources, it's necessary to limit
the search to a particular type:
</p>
<pre>
 GET [base]/DiagnosticReport?subject:Patient.name=peter
</pre>
<p>
Which is a request to return all the lab reports that have a subject which is a patient, whose name includes "peter".
</p>

<p>
Advanced Search Note:
Where a chained parameter searches a resource reference that may have more than one
different type of resource as its target, the parameter chain may end up referring
to search parameters with the same name on more than one kind of resource at once.
Servers SHOULD reject a search where the logical id refers to more than one matching 
resource across different types (e.g. the client has to specify the type explicitly 
using the syntax in the second example above).
</p>

<a name="composite" />
<a name="combining" />
<h4>Composite Search Parameters</h4>
<p>
The result of the search operation is the intersection of the resources that match the criteria specified by each
individual search parameter. If a parameter repeats, such as /Patient?language=FR&amp;language=NL, then
this matches a patient who speaks both languages. This is known as an AND search parameter, since the
server is expected to respond only with results which match both values.
</p>
<p>
If, instead, the search is to find patients that speak either
language, then this is a single parameter with multiple values, separated by a ','.
For example: "/Patient?language=FR,NL". This is known as an OR search parameter,
since the server is expected to respond with results which match either value.
</p>
<p>
AND parameters and OR parameters may also be combined, for example:
"/Patient?language=FR,NL&amp;language=EN" would refer to any patient who speaks
English as well as either French or Dutch.
</p>
<p>
This allows for simple combinations of and/or values, but doesn't allow a search based on
a pair of values, such as all observations with a sodium value >150 mmol/L (particularly
as the end criteria of a chained search), or searching on Group.characteristic: you need
find a combination of key/value, not an intersection of separate matches on key and value.
Another example is spatial coordinates when doing geographical searches.
</p>
<p>
To allow these searches, a resource may also specify <i>composite</i> parameters
that take sequences of single values that match other defined parameters as an
argument. The matching parameter of each component in such a sequence
is documented in the definition of the parameter. These sequences are formed by
joining the single values with a "$".  Note that this sequence is a single
value and itself can be composed into a set of values, so that, for example,
multiple matching state-on-date parameters can be specified as
state-on-date=new$2013-05-04,active$2013-05-05.
</p>
<p>
Modifiers are not used on composite parameters.
<!--
Future note: use \p and \m in search values? if we add a double = to parameter value for text, that would get rid
of <code>:exact</code>.
Won't try to get rid of type modifier - that's the real use for modifiers because it has to be in a chaining line.
Other modifier is <code>:text</code> on token - use "~"? or ""?
-->
</p>

<a name="escaping" />
<h4>Escaping Search Parameters</h4>
<p>
In the rules above, special rules are defined for the characters "$", ",", and "|".
As a consequence, if these characters appear in an actual parameter value,
they must be differentiated from their use as separator characters. When
any of these characters appear in an actual parameter value, they must be
prepended by the character "\" (which also must be used to prepend itself).
So "param=xxx$xxx" means a composite parameter, while "param=xx\$xx" means that
the parameter has the literal value 'xx$xx'. The parameter value "xx\xx" is illegal,
and the parameter value "param=xx\\xx" means a literal value of 'xx\xx'.
</p>


<a name="text"> </a>
<a name="content"> </a>
<h4>Text Search Parameters</h4>
<p>
There are two special text search parameters, _text and _content, which search
on the narrative of the resource, and the entire content of the resource respectively.
These parameters SHOULD support a sophisticated search functionality of the type
offered by typical text indexing services is appropriate.
The value of the parameter is a text based search, which may involve searching
multiple words with thesaurus and proximity considerations, and logical operations
such as AND, OR etc. For example:
</p>
<pre>
 GET [base]/Condition?_text=(bone OR liver) and metastases
</pre>
<p>
This searches for all Condition resources with the word "metastases" and either
"bone" or "liver" in the narrative. The server MAY choose to search
for related words as well.
</p>
<a name="dstu"> </a>
<blockquote>
<p><b>DSTU Note</b>: The issues around standardizing text search are not fully resolved.
During the trial use period for this specification, we recommend that systems use
the rules specified by <a href="http://docs.oasis-open.org/odata/odata/v4.0/cs01/part1-protocol/odata-v4.0-cs01-part1-protocol.html#_The_$search_System">
the OData specification for the $search parameter</a>.
Typical implementations would use Lucene, an sql-based full text search,
or some indexing service. Feedback about consistent implementation in this area
is welcome.
</p>
</blockquote>

<a name="list"> </a>
<h4>Searching by list</h4>

<p>
The _list parameter allows for the retrieval of resources that are referenced by a <a href="list.html">List</a>
resource. 
</p>
<pre>
 GET [base]/Patient?_list=42
</pre>
<p>
This returns all patient resources that are referenced from the list found at [base]/List/42) in List.entry.item.
While it is possible to retrieve the list, and then iterate the entries in the list fetching each
patient, using a list as a search criteria allows for additional search criteria to be specified. For 
instance:
</p>
<pre>
 GET [base]/Patient?_list=42&amp;gender=female
</pre>
<p>
which means, welect all the female patients in the list. The server can return the list referred 
to in the search parameter as an included resource, but is not required to do so. 
In addition, a system can support searching by lists by their logical function. For example:  
</p>
<pre>
 GET [base]/AllergyIntolerance?patient=42&amp;_list=$current-allergies
</pre>
<p>
This is a request to fetch all the allergies in the patient 42's "Currrent Allergy List".
The server returns all the relevant AllergyIntolerance resources, and can also choose
to return the list. For further information, refer to the <a href="lifecycle.html#current">definition of "$current-allergies"</a>,
and the <a href="list-operations.html#find">List Operation "Find"</a>.
Note that servers are not required to make these lists available to the clients as list resources,
but may choose to do so.
</p>

<a name="filter"> </a>
<a name="_filter"> </a>
<h4>Advanced filtering</h4>

<p>
The search mechanism described above is flexible, and easy to implement
for simple cases, but it is limited in its ability to express combination
queries. To complement this mechanism, a specific search expression
parameter can also be used, named "_filter".
</p>
<p>
For example, this is a moderately simple search: find all the
observations for patient with a name including "peter" that have a LOINC code 1234-5:
</p>
<pre>
GET [base]/Observation?name=http://loinc.org|1234-5&amp;subject.name=peter
</pre>
<p>
Using the _filter parameter, the search would be expressed like this:
</p>
<pre>
GET [base]/Observation?_filter=name eq http://loinc.org|1234-5 and subject.name co "peter"
</pre>
<p>
The _filter parameter is described in detail on the <a href="search_filter.html">"_Filter Parameter" page</a>.
</p>

<a name="return"> </a>
<h3>Managing Returned Resources</h3>

<a name="sort" />
<h4>Sorting</h4>
<p>
The client can indicate which order to return the results in
using the parameter "_sort", which can have a value of one of the search parameters.
The _sort parameter can repeat to indicate sort order, with the repeats indicating
a lower sort priority sequentially.
</p>
<p>
The _sort parameter takes one of two qualifiers, ":asc" and ":desc", which specify
ascending and descending sort order respectively. The default value is ":asc".
</p>
<p>
Notes:
</p>
<ul>
 <li>When sorting, the actual sort value used is not returned explicitly
by the server for each resource, just the resource contents</li>
 <li>To sort by relevance, use "_sort:asc=_score"</li>
 <li>The server returns the sort it performs as part of the returned search parameters (see <a href="#conformance">below</a>)</li>
 <li>A search parameter can refer to an element that repeat, and therefore
there can be multiple values for a given search parameter for a single
resource. In this case, the sort is based on the item in the set of
multiple parameters that comes earliest in the specified sort order
when ordering the returned resources. </li>
  <li>When sorting on string search parameters, sorting SHOULD be performed on a case-insensitive basis. Accents may either be ignored or sorted as per realm convention. Note: 
   Consistency of sorting across servers isn't as essential as consistency of filtering (even that is variable). The purpose of sorting is to provide data in a "reasonable" order for end users. 
   "Reasonable" may vary by realm, particularly for accented characters.</li>
</ul>

<a name="count"> </a>
<h4>Page Count</h4>

<p>
In order to keep the load on clients, servers and the network
minimized, the server may choose to return the results in
a series of pages. The search result set contains the URLs
that the client uses to request additional pages from the
search set. For a simple RESTful search, the page links are
<a href="http.html#paging">contained in the returned bundle as links</a>.
</p>
<p>
Typically a server will provide its own parameters in the links
that it uses to manage the state of the search as pages are
retrieved. These parameters do not need to be understood
or processed by the client.
</p>

<p>
The parameter _count is defined as a hint to the server
regarding how many resources should be returned in a
single page. Servers SHALL NOT return more resources than
requested (even if they don't support paging) but are
allowed to return less than the client asked for. The server should repeat 
the original _count parameter in its returned page links so that 
subsequent paging requests honour the original _count.  Note
that it is at the discretion of the search engine how to
handle ongoing updates to the resources while the search
is proceeding.
</p>

<p>
Note that the combination of _sort and _count can be used to return
just the latest resource that meets a particular criteria - set the
critera, and then sort by date in descending order, with _count=1.
This way, the last matching resource will be returned.
</p>

<a name="include"> </a>
<a name="revinclude"> </a>
<h4>Including other resources in result (_include and _revinclude)</h4>
<p>
Clients may request that the engine return additional resources related to
the search results, in order to reduce the overall network delay of repeated 
retrievals of related resources.
A typical case where this is useful is where the client is searching on
some type of clinical resource, but for every such resource returned,
the client will also need the subject (patient) resource that the
clinical resource refers to. The client requests that the subject
resources be included in the results set by providing one or more
_include parameters. An alternative scenario is where the client 
wishes to fetch a particular resource, and any resources that refer
to it. For example, the client may wish to fetch a MedicationOrder,
and any provenance resources that refer to the prescription. This is known
as a reverse include, and specified by providing a _revinclude parameter.
</p>
<p>
Both _include and _revinclude are based on search parameters, rather 
than paths in the resource, since joins (e.g. <a href="#chaining">chaining</a>
are already done by search parameter.
</p> 
<p>
Each _include parameter specifies a search parameter to join on:
</p>
<pre>
 GET [base]/MedicationOrder?_include=MedicationOrder:patient&amp;criteria...
 GET [base]/MedicationOrder?_revinclude=Provenance:target&amp;criteria...
</pre>
<p>
  The first search means, for any matching MedicationOrder, include 
any patient that the medication prescriptions in the result set refer to. 
The second search means, for any matching prescriptions, return all 
the provenance resources that refer to them. 
</p>
<p>
Parameter values for both _include and _revinclude have 3 parts, separated by a ":" separator:
</p>
<ol>
 <li>The name of the source resource from which the join comes</li>
 <li>The name of the search parameter which must be of type <i>reference</i></li>
 <li>(Optional) A specific of type of target resource (for when the search parameter refers to multiple possible target types)</li>
</ol>
<p>
_include and _reverseInclude parameters do not include multiple values. Instead, the 
parameters are repeated for each different include criteria.
</p>
<p>
For each returned resource, the server identifies the resources that meet
the criteria expressed in the join, and adds to the results,
with the <a href="bundle-definitions.html#Bundle.entry.status">entry.status</a>
set to "include" (in some searches, it is not obvious which resources are
matches, and which are includes).
</p>
<p>
The inclusion process can be recursive, if the modifier <code>:recurse</code> is included. 
  For example, this example search returns all the <a href="medicationorder.html">Medication
Prescription</a> resources and their <a href="practitioner.html">prescribing Practitioner</a> Resources
for the matching <a href="medicationdispense.html">Medication Dispense</a> resources:
</p>
<pre>
GET [base]/MedicationDispense?_include=MedicationDispense.authorizingPrescription
    &amp;_include:recurse=MedicationOrder.prescriber&amp;criteria...
</pre>
<p>
This technique applies to circular relationships as well. For example, 
the first of these two searches includes any related observations to the 
target relationships, but only those directly related. The second search
asks for the _include based on <code>related</code> parameter to be executed
recursively, so will retrieve observations that are directly related, and 
also any related observations to any other included observation.
</p>
<pre>
GET [base]/Observation?_include=Observation.related-target&amp;criteria...
GET [base]/Observation?_include:recurse=Observation.related-target&amp;criteria...
</pre>
<p>
Both _include and _reverseInclude and use the wild card "*" for the search parameter
name, indicating by this that any search parameter of type=reference be included, though 
though both clients and servers need to take care not to request or return too many resources
when doing this. Most notably, using recursive inclusions might lead to the retrieval of the 
full patient's record, or even more: resources are organized into an interlinked network 
and broad _include paths may eventually traverse all possible paths on the server. For 
servers, these recursive and wildcard _includes are demanding and may slow the search 
response time significantly. 
</p>
<p>
It is at the server's discretion how deep to recursively evaluate the inclusions. 
Servers are expected to limit the number of iterations done to an appropriate level 
and are not obliged to honor requests to include additional resources in the search results.
</p>
<p>
When the search results are paged, each page of search results should include 
the matching includes for the resources in each page, so that each page stands
alone as a coherent package.
</p>


<a name="contained"> </a>
<a name="containedType"> </a>


<h4>Contained Resources</h4>

<p>
By default, search results only include resources that are not contained in other resources. 
A chained condition will be evaluated inside contained resources. To illustrate this, consider
a MedicationOrder resource that has a contained Medication resource specifying 
a custom formulation that has ingredient that has a value Substance/x23. In this case, a search:
</p>
<pre>
GET MedicationOrder?medication.ingredient=Substance/x23
</pre>
<p>
  will include the MedicationOrder resource in the results. However this search:
</p>
<pre>
GET Medication?ingredient=Substance/x23
</pre>
<p>
will not include the contained Medication resource in the results, since either the 
wrong type of resource would be returned, or the contained resource would be returned
without it's container resource, which provides context to the contained resource.
</p>
<p>
Clients are able to modify this behavior using the _contained parameter, which
can have one of the following values:
</p>
<ul>
 <li>false (default): Do not return contained resources</li>
 <li>true: return only contained resources</li>
 <li>both: return both contained and non-contained (normal) resources</li>
</ul>
<p>
When contained resources are being returned, the server 
should return either the container resource, or the contained resource alone. The 
client can specify which by using the _containedType parameter, which can have one of the 
following values:
</p>
<ul>
 <li>container (default): Return the container resources</li>
 <li>contained: return only the contained resource</li>
</ul>
<p>
When returning a container resource, the server simply puts this in the 
search results:
</p>
<pre>
&lt;Bundle&gt;
  ...
  &lt;entry&gt;
    &lt;resource&gt;
      &lt;MedicationOrder&gt;
        &lt;id value=&quot;23&quot;&gt;
        ....
        &lt;contained&gt;
          &lt;Medication&gt;
            &lt;id value=&quot;m1&quot;&gt;
            ...
          &lt;/Medication&gt;
        &lt;contained&gt;

      &lt;/MedicationOrder&gt;
    &lt;/resource&gt;
    &lt;search&gt;
      &lt;mode value=&quot;match&quot;/&gt;
    &lt;/search&gt;
  &lt;/entry&gt;
&lt;/Bundle&gt;
</pre>
<p>
In the case of returning container resources, the server SHALL populate the entry.search.mode
element so that the client can pick matches and includes apart (the usual approach of doing it
by type may not work). If the return type is the contained resource, this must be done slightly 
differently:
</p>
<pre>
&lt;Bundle&gt;
  ...
  &lt;entry&gt;
    &lt;fullUrl value=&quot;http://example.com/fhir/MedicationOrder/23#&quot;/&gt;
    &lt;resource&gt;
      &lt;Medication&gt;
        &lt;id value=&quot;m1&quot;&gt;
        ...
      &lt;/Medication&gt;
    &lt;/resource&gt;
    &lt;search&gt;
      &lt;mode value=&quot;match&quot;/&gt;
    &lt;/search&gt;
  &lt;/entry&gt;
&lt;/Bundle&gt;
</pre>
<p>
In this case, the fullUrl informs the client that this is a contained resource,
and the identity of the containing resource.
</p>

<a name="external"> </a>

<h4>External References</h4>
<p>
If the _include path selects a reference that refers to a resource on another server,
the server can elect to include that resource in the search results for the convenience
of the client.
</p>
<p>
If the _include path selects a reference that refers to an entity that is not a Resource
(e.g. an image attachment), the server may also elect to include this in the returned
results as a <a href="compartments.html#binary">Binary</a> resource. For example, the include
path may point to an attachment which is by reference, like this:
</p>
<pre>
 &lt;content&gt;
   &lt;contentType&gt;image/jpeg&lt;/contentType&gt;
   &lt;url&gt;http://example.org/images/2343434/234234.jpg&lt;/url&gt;
 &lt;/content&gt;
</pre>
<p>
The server can retrieve the target of this reference, and add this to the
results for the convenience of the client.
</p>

<a name="dstu-2"> </a>
<blockquote>
<p><b>DSTU Note</b>: HL7 is seeking feedback from implementers about whether additional
rules should be made about how _include works, based on implementation experience.
</p>
</blockquote>


<h4>Paging</h4>
<p>
When returning paged results for a search with _include resources, all _include resources that are
related to the primary resources returned for the page SHOULD also be returned as part of that
same page, even if some of those resource instances have previously been returned on previous
pages.  This allows both sender and receiver to avoid caching results of other pages.
</p>

<a name="summary"> </a>
<h4>Summary</h4>
<p>
The client can request the server to return a portion of the resources
only using the parameter "_summary":
</p>
<pre>
   GET [base]/ValueSet?_summary=true
</pre>
<p>
The <i>_summary</i> parameter requests the server to return only a subset of the 
resource. It can have one of the following values:
</p>
<table class="codes">
 <tr><td><a href="#summary-true">true</a></td><td>Return only those elements marked as 'summary' in the base definition of the resource(s)</td></tr>
 <tr><td><a href="#summary-text">text</a></td><td>Return only the 'text' element, and any mandatory elements</td></tr>
 <tr><td><a href="#summary-data">data</a></td><td>Remove the text element</td></tr>
 <tr><td><a href="#summary-count">count</a></td><td>Search only: just return a count of the matching resources, without returning the actual matches</td></tr>
 <tr><td><a href="#summary-false">false</a></td><td>Return all parts of the resource(s)</td></tr>
</table>
<p>
The intent of the _summary parameter is to reduce the total processing load on
server, client, and resources between them such as the network. It is most useful for
resources that can be large, particularly ones that include images or elements that
may repeat many times.
</p>
<p>
Servers are not obliged to return just a summary as requested. There is only 
alimited number of summary forms defined for resources in order to allow servers 
to store the summarized form in advance. Servers SHOULD mark the resources with the 
tag <a href="v3/SecurityIntegrityObservationValue/index.html#SUBSETTED">SUBSETTED</a> 
to ensure that the incomplete resource is not actually used to overwrite 
a complete resource.
</p>

<a name="elements"> </a>
<h4>Elements</h4>
<p>
If one of the summary views defined above is not appropriate, a client can 
request a specific set of elements be returned as part of a resource using
the _elements parameter:
</p>
<pre>
   GET [base]/Patient?_elements=identifier,active,link
</pre>
<p>
The _elements parameter consists of a comma separated list of base element
names (e.g. elements defined at the root level in the resource). Only 
elements that are listed are to be returned. Clients SHOULD list all mandatory
elements in a resource as part of the list of elements. The list of elements
does not apply to <a href="#include">included resources</a>.
</p>
<p>
Servers are not obliged to return just the requested elements. 
Servers SHOULD always return mandatory elements whether they are 
requested or not. Servers SHOULD mark the resources with the 
tag <a href="v3/SecurityIntegrityObservationValue/index.html#SUBSETTED">SUBSETTED</a> 
to ensure that the incomplete resource is not actually used to overwrite 
a complete resource.
</p>

<a name="score"> </a>
<h4>Relevance</h4>
<p>
Where a search specifies a non-deterministic sort, the search algorithm
may generate some kind of ranking score to indicate which resources meet
the specified criteria better than others. The server can return this
score in <a href="bundle-definitions.html#Bundle.entry.score">entry.score</a>:
</p>
<pre class="xml">
  &lt;entry&gt;
    &lt;score value=&quot;.45&quot;/&gt;
    &lt;Patient&gt;
      ... patient data ...
    &lt;/Patient&gt;
  &lt;/entry&gt;
</pre>
<p>
The score is a decimal number with a value between (and including) 0 and 1, where 1 is best match, and 0 is least match.
</p>

<a name="conformance" />
<h3>Server Conformance</h3>
<p>
In order to allow the client to be confident about what search parameters
were used as a criteria by the server, the server SHALL return the parameters
that were actually used to process the search. Applications processing search
results SHALL check these returned values where necessary. For example, if
the server did not support some of the filters specified in the search, a
client might manually apply those filters to the retrieved result set,
display a warning message to the user or take some other action.
</p>
<p>
In the case of a RESTful search, these parameters are encoded in the
self link in the bundle that is returned:
</p>
<pre class="xml">
  &lt;link&gt;
    &lt;relation value="self"/&gt;
    &lt;url value="http://example.org/Patient?name=peter"/&gt;
  &lt;/link&gt;
</pre>
<p>
In other respects, servers have considerable discretion with regards
to supporting search:
</p>
<ul>
 <li>Servers can choose which parameters to support (other than _id above)</li>
 <li>Servers can choose when and where to implement parameter chaining, and when and where they support the _include parameter</li>
 <li>Servers are able to declare additional parameters in the profiles referenced from their conformance statements. Servers should define search parameters
    starting with a "-" character to ensure that the names they choose do not clash with future parameters defined by this specification</li>
 <li>Servers are not required to enforce case sensitivity on parameter names, though the names are case sensitive (and URLs are generally case-sensitive)</li>
 <li>Servers may choose how many results to return, though the client can use _count as above</li>
 <li>Servers can choose how to sort the return results, though they SHOULD honor the _sort parameter</li>
</ul>

<hr/>
<a name="advanced"> </a>
<a name="query"> </a>
<h3>Advanced Search</h3>
<p>
The search framework described above is a useful framework
for providing a simple search based on indexed criteria,
but more sophisticated query capability is needed to handle precise
queries, complex decision support based requests, and
direct queries that have human resolution.
</p>
<p>
More advanced search operations are specified by the
_query parameter:
</p>
<pre>
   GET [base]/Patient?_query=name&amp;parameters...
</pre>
<p>
The _query parameter names a custom search profile that
describes a specific query operation. The named query
may define additional named parameters that are used with that
particular named query. Servers can define their own additional
named queries to meet their own uses using a <a href="operationdefinition.html">OperationDefinition</a>.
</p>
<p>
There can only ever be one _query parameter in a set of search
parameters. Servers processing search requests SHALL
refuse to process a search request if they do not recognize
the _query parameter value.
</p>

<a name="currency"> </a>
<h3>Search Result Currency</h3>

<p>
The results of a search operation are only guaranteed to be current
at the moment the operation is executed. After the operation is executed,
ongoing actions performed on the resources against which the search was
executed will render the results increasingly stale. The significance
of this depends on the nature of the search, and the kind of use that
is being made of the results.
</p>
<p>
This is particularly relevant when the server is returning the results
in a series of pages. It is at the discretion of the search engine
how to handle ongoing updates to the resources while the search
is proceeding.
</p>
<p>
Note that performing a search operation does not change the set of
resources on the server, with the exception of the creation
of <a href="auditevent.html">Audit Event</a> resources
auditing the search itself.
</p>

<a name="table"> </a>
<h3>Summary Tables</h3>

<table class="list">
<tr><td colspan="4">Common Parameters defined for all resources:</td></tr>
<tr><td><b>Name</b></td><td><b>Type</b></td><td><b>Description</b></td><td><b>Paths</b></td></tr>
<tr><td><a href="#id">_id</a></td><td><a href="#string">string</a></td><td>Resource id (not a full URL)</td><td>Resource.id</td></tr>
<tr><td><a href="#lastUpdated">_lastUpdated</a></td><td><a href="#date">date</a></td><td>Date last updated. Server has discretion on the boundary precision</td><td>Resource.meta.lastUpdated</td></tr>
<tr><td><a href="#tag">_tag</a></td><td><a href="#token">token</a></td><td>Search by a resource tag</td><td>Resource.meta.tag</td></tr>
<tr><td><a href="#profile">_profile</a></td><td><a href="#uri">uri</a></td><td>Search for all resources tagged with a profile</td><td>Resource.meta.profile</td></tr>
<tr><td><a href="#security">_security</a></td><td><a href="#token">token</a></td><td>Search by a security label</td><td>Resource.meta.security</td></tr>
<tr><td><a href="#text">_text</a></td><td><a href="#string">string</a></td><td>Text search against the narrative</td><td></td></tr>
<tr><td><a href="#content">_content</a></td><td><a href="#string">string</a></td><td>Text search against the entire resource</td><td></td></tr>
<tr><td><a href="#list">_list</a></td><td><a href="#string">string</a></td><td>All resources in nominated list (by id, not a full URL)</td><td></td></tr>
<tr><td><a href="#query">_query</a></td><td><a href="#string">string</a></td><td>Custom named query</td><td></td></tr>
<tr><td colspan="4">Search Control Parameters:</td></tr>
<tr><td><b>Name</b></td><td><b>Type</b></td><td><b>Description</b></td><td><b>Allowable Content</b></td></tr>
<tr><td><a href="#sort">_sort</a></td><td><a href="#string">string</a></td><td>Order to sort results in (can repeat for inner sort orders)</td><td>The name of a valid search parameter</td></tr>
<tr><td><a href="#count">_count</a></td><td><a href="#number ">number </a></td><td>Number of results per page</td><td>Whole Number</td></tr>
<tr><td><a href="#include">_include</a></td><td><a href="#string">string</a></td><td>Other resources to include in the search results that search matches point to</td><td>SourceType:searchParam(:targetType)</td></tr>
<tr><td><a href="#revinclude">_revinclude</a></td><td><a href="#string">string</a></td><td>Other resources to include in the search results when they refer to search matches</td><td>SourceType:searchParam(:targetType)</td></tr>
<tr><td><a href="#summary">_summary</a></td><td><a href="#string">string</a></td><td>Just return the summary elements (for resources where this is defined)</td><td>true | false (false is default)</td></tr>
<tr><td><a href="#contained">_contained</a></td><td><a href="#string">string</a></td><td>Whether to return resources contained in other resources in the search matches</td><td>true | false | both (false is default)</td></tr>
<tr><td><a href="#containedType">_containedType</a></td><td><a href="#string">string</a></td><td>If returning contained resources, whether to return the contained or container resources</td><td>container | contained</td></tr>
</table>

<p>
Cross-map between search parameter types and Data types:
</p>
<table class="list">
 <tr>
  <td><b>Data Type</b></td>
  <td><b><a href="#number">number</a></b></td>
  <td><b><a href="#date">date</a></b></td>
  <td><b><a href="#string">string</a></b></td>
  <td><b><a href="#token">token</a></b></td>
  <td><b><a href="#reference">reference</a></b></td>
  <td><b><a href="#quantity">quantity</a></b></td>
  <td><b><a href="#uri">uri</a></b></td>
 </tr>
 <tr>
  <td><a href="datatypes.html#boolean">boolean</a></td>
  <td><%xcm boolean:number%></td> <!-- number -->
  <td><%xcm boolean:date%></td> <!-- date -->
  <td><%xcm boolean:string%></td> <!-- string -->
  <td><%xcm boolean:token%>. true|false (System = http://hl7.org/fhir/special-values but not usually needed)</td> <!-- token -->
  <td><%xcm boolean:reference%></td> <!-- reference -->
  <td><%xcm boolean:quantity%></td> <!-- quantity -->
  <td><%xcm boolean:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#code">code</a></td>
  <td><%xcm code:number%></td> <!-- number -->
  <td><%xcm code:date%></td> <!-- date -->
  <td><%xcm code:string%></td> <!-- string -->
  <td><%xcm code:token%>. (System, if desired, is defined in the underlying value set for eeach code)</td> <!-- token -->
  <td><%xcm code:reference%></td> <!-- reference -->
  <td><%xcm code:quantity%></td> <!-- quantity -->
  <td><%xcm code:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#date">date</a></td>
  <td><%xcm date:number%></td> <!-- number -->
  <td><%xcm date:date%></td> <!-- date -->
  <td><%xcm date:string%></td> <!-- string -->
  <td><%xcm date:token%></td> <!-- token -->
  <td><%xcm date:reference%></td> <!-- reference -->
  <td><%xcm date:quantity%></td> <!-- quantity -->
  <td><%xcm date:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#dateTime">dateTime</a></td>
  <td><%xcm dateTime:number%></td> <!-- number -->
  <td><%xcm dateTime:date%></td> <!-- date -->
  <td><%xcm dateTime:string%></td> <!-- string -->
  <td><%xcm dateTime:token%></td> <!-- token -->
  <td><%xcm dateTime:reference%></td> <!-- reference -->
  <td><%xcm dateTime:quantity%></td> <!-- quantity -->
  <td><%xcm dateTime:number%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#instant">instant</a></td>
  <td><%xcm instant:number%></td> <!-- number -->
  <td><%xcm instant:date%></td> <!-- date -->
  <td><%xcm instant:string%></td> <!-- string -->
  <td><%xcm instant:token%></td> <!-- token -->
  <td><%xcm instant:reference%></td> <!-- reference -->
  <td><%xcm instant:quantity%></td> <!-- quantity -->
  <td><%xcm instant:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#integer">integer</a></td>
  <td><%xcm integer:number%></td> <!-- number -->
  <td><%xcm integer:date%></td> <!-- date -->
  <td><%xcm integer:string%></td> <!-- string -->
  <td><%xcm integer:token%></td> <!-- token -->
  <td><%xcm integer:reference%></td> <!-- reference -->
  <td><%xcm integer:quantity%></td> <!-- quantity -->
  <td><%xcm integer:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#oid">oid</a></td>
  <td><%xcm oid:number%></td> <!-- number -->
  <td><%xcm oid:date%></td> <!-- date -->
  <td><%xcm oid:string%></td> <!-- string -->
  <td><%xcm oid:token%></td> <!-- token -->
  <td><%xcm oid:reference%></td> <!-- reference -->
  <td><%xcm oid:quantity%></td> <!-- quantity -->
  <td><%xcm oid:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#string">string</a></td>
  <td><%xcm string:number%></td> <!-- number -->
  <td><%xcm string:date%></td> <!-- date -->
  <td><%xcm string:string%></td> <!-- string -->
  <td><%xcm string:token%></td> <!-- token -->
  <td><%xcm string:reference%></td> <!-- reference -->
  <td><%xcm string:quantity%></td> <!-- quantity -->
  <td><%xcm string:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#uri">uri</a></td>
  <td><%xcm uri:number%></td> <!-- number -->
  <td><%xcm uri:date%></td> <!-- date -->
  <td><%xcm uri:string%> </td> <!-- string -->
  <td><%xcm uri:token%></td> <!-- token -->
  <td><%xcm uri:reference%></td> <!-- reference -->
  <td><%xcm uri:quantity%></td> <!-- quantity -->
  <td><%xcm uri:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Address">Address</a></td>
  <td><%xcm Address:number%></td> <!-- number -->
  <td><%xcm Address:date%></td> <!-- date -->
  <td><%xcm Address:string%> search on any elements in the address</td> <!-- string -->
  <td><%xcm Address:token%></td> <!-- token -->
  <td><%xcm Address:reference%></td> <!-- reference -->
  <td><%xcm Address:quantity%></td> <!-- quantity -->
  <td><%xcm Address:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Annotation">Annotation</a></td>
  <td><%xcm Annotation:number%></td> <!-- number -->
  <td><%xcm Annotation:date%></td> <!-- date -->
  <td><%xcm Annotation:string%></td> <!-- string -->
  <td><%xcm Annotation:token%></td> <!-- token -->
  <td><%xcm Annotation:reference%></td> <!-- reference -->
  <td><%xcm Annotation:quantity%></td> <!-- quantity -->
  <td><%xcm Annotation:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#CodeableConcept">CodeableConcept</a></td>
  <td><%xcm CodeableConcept:number%></td> <!-- number -->
  <td><%xcm CodeableConcept:date%></td> <!-- date -->
  <td><%xcm CodeableConcept:string%></td> <!-- string -->
  <td><%xcm CodeableConcept:token%></td> <!-- token -->
  <td><%xcm CodeableConcept:reference%></td> <!-- reference -->
  <td><%xcm CodeableConcept:quantity%></td> <!-- quantity -->
  <td><%xcm CodeableConcept:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Coding">Coding</a></td>
  <td><%xcm Coding:number%></td> <!-- number -->
  <td><%xcm Coding:date%></td> <!-- date -->
  <td><%xcm Coding:string%></td> <!-- string -->
  <td><%xcm Coding:token%></td> <!-- token -->
  <td><%xcm Coding:reference%></td> <!-- reference -->
  <td><%xcm Coding:quantity%></td> <!-- quantity -->
  <td><%xcm Coding:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#ContactPoint">ContactPoint</a></td>
  <td><%xcm ContactPoint:number%></td> <!-- number -->
  <td><%xcm ContactPoint:date%></td> <!-- date -->
  <td><%xcm ContactPoint:string%></td> <!-- string -->
  <td><%xcm ContactPoint:token%></td> <!-- token -->
  <td><%xcm ContactPoint:reference%></td> <!-- reference -->
  <td><%xcm ContactPoint:quantity%></td> <!-- quantity -->
  <td><%xcm ContactPoint:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Duration">Duration</a></td>
  <td><%xcm Duration:number%></td> <!-- number -->
  <td><%xcm Duration:date%></td> <!-- date -->
  <td><%xcm Duration:string%></td> <!-- string -->
  <td><%xcm Duration:token%></td> <!-- token -->
  <td><%xcm Duration:reference%></td> <!-- reference -->
  <td><%xcm Duration:quantity%></td> <!-- quantity -->
  <td><%xcm Duration:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#HumanName">HumanName</a></td>
  <td><%xcm HumanName:number%></td> <!-- number -->
  <td><%xcm HumanName:date%></td> <!-- date -->
  <td><%xcm HumanName:string%> Search on any element in the name</td> <!-- string -->
  <td><%xcm HumanName:token%></td> <!-- token -->
  <td><%xcm HumanName:reference%></td> <!-- reference -->
  <td><%xcm HumanName:quantity%></td> <!-- quantity -->
  <td><%xcm HumanName:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Identifier">Identifier</a></td>
  <td><%xcm Identifier:number%></td> <!-- number -->
  <td><%xcm Identifier:date%></td> <!-- date -->
  <td><%xcm Identifier:string%></td> <!-- string -->
  <td><%xcm Identifier:token%></td> <!-- token -->
  <td><%xcm Identifier:reference%></td> <!-- reference -->
  <td><%xcm Identifier:quantity%></td> <!-- quantity -->
  <td><%xcm Identifier:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Period">Period</a></td>
  <td><%xcm Period:number%></td> <!-- number -->
  <td><%xcm Period:date%></td> <!-- date -->
  <td><%xcm Period:string%></td> <!-- string -->
  <td><%xcm Period:token%></td> <!-- token -->
  <td><%xcm Period:reference%></td> <!-- reference -->
  <td><%xcm Period:quantity%></td> <!-- quantity -->
  <td><%xcm Period:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Quantity">Quantity</a></td>
  <td><%xcm Quantity:number%></td> <!-- number -->
  <td><%xcm Quantity:date%></td> <!-- date -->
  <td><%xcm Quantity:string%></td> <!-- string -->
  <td><%xcm Quantity:token%></td> <!-- token -->
  <td><%xcm Quantity:reference%></td> <!-- reference -->
  <td><%xcm Quantity:quantity%></td> <!-- quantity -->
  <td><%xcm Quantity:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Range">Range</a></td>
  <td><%xcm Range:number%></td> <!-- number -->
  <td><%xcm Range:date%></td> <!-- date -->
  <td><%xcm Range:string%></td> <!-- string -->
  <td><%xcm Range:token%></td> <!-- token -->
  <td><%xcm Range:reference%></td> <!-- reference -->
  <td><%xcm Range:quantity%></td> <!-- quantity -->
  <td><%xcm Range:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Reference">Reference</a></td>
  <td><%xcm Reference:number%></td> <!-- number -->
  <td><%xcm Reference:date%></td> <!-- date -->
  <td><%xcm Reference:string%></td> <!-- string -->
  <td><%xcm Reference:token%></td> <!-- token -->
  <td><%xcm Reference:reference%></td> <!-- reference -->
  <td><%xcm Reference:quantity%></td> <!-- quantity -->
  <td><%xcm Reference:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#SampledData">SampledData</a></td>
  <td><%xcm SampledData:number%></td> <!-- number -->
  <td><%xcm SampledData:date%></td> <!-- date -->
  <td><%xcm SampledData:string%></td> <!-- string -->
  <td><%xcm SampledData:token%></td> <!-- token -->
  <td><%xcm SampledData:reference%></td> <!-- reference -->
  <td><%xcm SampledData:quantity%></td> <!-- quantity -->
  <td><%xcm SampledData:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Timing">Timing</a></td>
  <td><%xcm Timing:number%></td> <!-- number -->
  <td><%xcm Timing:date%></td> <!-- date -->
  <td><%xcm Timing:string%></td> <!-- string -->
  <td><%xcm Timing:token%></td> <!-- token -->
  <td><%xcm Timing:reference%></td> <!-- reference -->
  <td><%xcm Timing:quantity%></td> <!-- quantity -->
  <td><%xcm Timing:uri%></td> <!-- uri -->
 </tr>
</table>

</div>

[%file newfooter%]
</body>
</html>

